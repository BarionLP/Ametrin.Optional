using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Ametrin.Optional.Analyzer;

[Generator]
public sealed class SpanParsableGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var nodes = context.SyntaxProvider.ForAttributeWithMetadataName(
            "Ametrin.Optional.Parsing.GenerateISpanParsableAttribute",
            static (node, _) => node is ClassDeclarationSyntax or StructDeclarationSyntax or RecordDeclarationSyntax,
            static (ctx, cancellationToken) => (INamedTypeSymbol)ctx.SemanticModel.GetDeclaredSymbol(ctx.TargetNode, cancellationToken)!
        );

        context.RegisterSourceOutput(nodes, static (context, type) =>
        {
            var sb = new StringBuilder();

            sb.AppendLine("using Ametrin.Optional.Parsing;");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Diagnostics.CodeAnalysis;");
            sb.AppendLine();

            if (!type.ContainingNamespace.IsGlobalNamespace)
            {
                sb.AppendLine($"namespace {type.ContainingNamespace};");
                sb.AppendLine();
            }

            sb.AppendLine("// This file is generated by Ametrin.Optional");
            sb.AppendLine("#nullable enable");
            sb.AppendLine();

            var containers = new Stack<INamedTypeSymbol>();
            for (var t = type.ContainingType; t is not null; t = t.ContainingType) containers.Push(t);
            foreach (var c in containers)
            {
                sb.AppendLine(BuildTypeHeader(c));
                sb.AppendLine("{");
            }

            sb.AppendLine($$"""
            {{BuildTypeHeader(type)}} : ISpanParsable<{{type.Name}}>
            {
                public static {{type.Name}} Parse(string? s, IFormatProvider? provider = null)
                    => {{type.Name}}.TryParse(s, provider).OrThrow();

                public static {{type.Name}} Parse(ReadOnlySpan<char> s, IFormatProvider? provider = null)
                    => {{type.Name}}.TryParse(s, provider).OrThrow();

                public static bool TryParse(string? s, IFormatProvider? provider, [MaybeNullWhen(false)] out {{type.Name}} result)
                    => {{type.Name}}.TryParse(s, provider).Branch(out result);
                
                public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, [MaybeNullWhen(false)] out {{type.Name}} result)
                    => {{type.Name}}.TryParse(s, provider).Branch(out result);
            """);

            sb.AppendLine("}");

            foreach (var c in containers)
            {
                sb.AppendLine("}");
            }

            context.AddSource($"{type.Name}.Parsing.g.cs", sb.ToString());
        });
    }

    private static string BuildTypeHeader(INamedTypeSymbol type)
    {
        var kind = type switch
        {
            { IsRecord: true, TypeKind: TypeKind.Struct } => "record struct",
            { IsRecord: true, TypeKind: TypeKind.Class } => "record",
            { TypeKind: TypeKind.Struct } => "struct",
            _ => "class",
        };

        var refMod = type is { IsRefLikeType: true, TypeKind: TypeKind.Struct } ? "ref " : "";

        return $"{refMod}partial {kind} {type.Name}";
    }
}
