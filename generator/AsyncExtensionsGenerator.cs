namespace Ametrin.Optional.Generator;

[Generator]
public sealed class AsyncExtensionsGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var nodes = context.SyntaxProvider.ForAttributeWithMetadataName(
            "Ametrin.Optional.Generator.GenerateAsyncExtensionsAttribute",
            static (node, _) => node is ClassDeclarationSyntax or StructDeclarationSyntax or RecordDeclarationSyntax,
            static (ctx, cancellationToken) => (INamedTypeSymbol)ctx.SemanticModel.GetDeclaredSymbol(ctx.TargetNode, cancellationToken)!
        );

        context.RegisterSourceOutput(nodes, static (context, type) =>
        {
            var methods = type.GetMembers().OfType<IMethodSymbol>().Where(static method => HasAttribute(method, IsAsyncExtensionAttribute));

            var sb = new StringBuilder();

            sb.AppendLine("using System.Threading.Tasks;");
            sb.AppendLine();

            if (!type.ContainingNamespace.IsGlobalNamespace)
            {
                sb.AppendLine($"namespace {type.ContainingNamespace};");
                sb.AppendLine();
            }

            sb.AppendLine("// This file is generated by Ametrin.Optional");
            sb.AppendLine("#nullable enable");
            sb.AppendLine();

            sb.AppendLine($$"""
            public static partial class Generated{{type.Name}}AsyncExtensions
            {
            """);

            foreach (var method in methods)
            {
                foreach (var attribute in method.GetAttributes().Where(static data => !IsAsyncExtensionAttribute(data.AttributeClass)))
                {
                    sb.AppendLine($"    [{attribute}]");
                }

                var generics = string.Join(", ", type.TypeParameters.Concat(method.TypeParameters));
                if (!string.IsNullOrEmpty(generics))
                {
                    generics = $"<{generics}>";
                }

                if (IsTask(method.ReturnType))
                {
                    sb.AppendLine($$"""
                    public static async {{method.ReturnType}} {{method.Name}}{{generics}}(this Task<{{type}}> task{{(method.Parameters.Length > 0 ? ", " : "")}}{{string.Join(", ", method.Parameters)}})
                    {
                        {{(method.ReturnType is INamedTypeSymbol { TypeParameters.Length: > 0 } ? "return " : "")}}await (await task).{{method.Name}}({{string.Join(", ", method.Parameters.Select(p => p.Name))}});
                    }
                """);
                }
                else
                {
                    // ContinueWith is 42x slower and uses 2.7x memory (.NET 9)
                    sb.AppendLine($$"""
                    public static async {{(method.ReturnsVoid ? "Task" : $"Task<{method.ReturnType}>")}} {{method.Name}}Async{{generics}}(this Task<{{type}}> task{{(method.Parameters.Length > 0 ? ", " : "")}}{{string.Join(", ", method.Parameters)}})
                    {
                        {{(method.ReturnsVoid ? "" : "return ")}}(await task).{{method.Name}}({{string.Join(", ", method.Parameters.Select(p => p.Name))}});
                    }
                """);
                }

            }

            sb.AppendLine("}");

            context.AddSource($"{type.Name}{type.TypeParameters.Length}.AsyncExtensions.g.cs", sb.ToString());
        });
    }

    internal static bool HasAttribute(ISymbol symbol, Func<INamedTypeSymbol?, bool> predicate) => symbol.GetAttributes().Any(data => predicate(data.AttributeClass));
    internal static bool IsAsyncExtensionAttribute(INamedTypeSymbol? attribute) => attribute is { Name: "AsyncExtensionAttribute", ContainingAssembly.Name: "Ametrin.Optional" };
    internal static bool IsTask(ITypeSymbol? attribute) => attribute is { Name: "Task", ContainingAssembly.Name: "System.Runtime", ContainingNamespace: { Name: "Tasks", ContainingNamespace: { Name: "Threading", ContainingNamespace.Name: "System" } } };
}
