namespace Ametrin.Optional.Generator;

[Generator]
public sealed class AsyncExtensionsGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var nodes = context.SyntaxProvider.ForAttributeWithMetadataName(
            "Ametrin.Optional.Generator.GenerateAsyncExtensionsAttribute",
            static (node, _) => node is ClassDeclarationSyntax or StructDeclarationSyntax or RecordDeclarationSyntax,
            static (ctx, cancellationToken) => (INamedTypeSymbol)ctx.SemanticModel.GetDeclaredSymbol(ctx.TargetNode, cancellationToken)!
        );

        context.RegisterSourceOutput(nodes, static (context, type) =>
        {
            var methods = type.GetMembers().OfType<IMethodSymbol>().Where(static method => HasAttribute(method, IsAsyncExtensionAttribute));

            var sb = new StringBuilder();

            sb.AppendLine("using System.Threading.Tasks;");
            sb.AppendLine();

            if (!type.ContainingNamespace.IsGlobalNamespace)
            {
                sb.AppendLine($"namespace {type.ContainingNamespace};");
                sb.AppendLine();
            }

            sb.AppendLine("// This file is generated by Ametrin.Optional");
            sb.AppendLine("#nullable enable");
            sb.AppendLine();

            sb.AppendLine($$"""
            public static partial class Generated{{type.Name}}AsyncExtensions
            {
            """);

            foreach (var method in methods)
            {
                foreach (var attribute in method.GetAttributes().Where(static data => !IsAsyncExtensionAttribute(data.AttributeClass)))
                {
                    sb.AppendLine($"    [{attribute}]");
                }

                if (method.IsAsync)
                {
                    sb.AppendLine($$"""
                    public static async {{method.ReturnType}} {{method.Name}}<{{string.Join(", ", type.TypeParameters.Concat(method.TypeParameters))}}>(this Task<{{type}}> task{{(method.Parameters.Length > 0 ? ", " : "")}}{{string.Join(", ", method.Parameters)}})
                    {
                        return await (await task).{{method.Name}}({{string.Join(", ", method.Parameters.Select(p => p.Name))}});
                    }
                """);
                }
                else
                {
                    sb.AppendLine($$"""
                    public static async Task<{{method.ReturnType}}> {{method.Name}}Async<{{string.Join(", ", type.TypeParameters.Concat(method.TypeParameters))}}>(this Task<{{type}}> task{{(method.Parameters.Length > 0 ? ", " : "")}}{{string.Join(", ", method.Parameters)}})
                    {
                        return (await task).{{method.Name}}({{string.Join(", ", method.Parameters.Select(p => p.Name))}});
                    }
                """);
                }

            }

            sb.AppendLine("}");

            context.AddSource($"{type.Name}{type.TypeParameters.Length}.AsyncExtensions.g.cs", sb.ToString());
        });
    }

    internal static bool HasAttribute(ISymbol symbol, Func<INamedTypeSymbol?, bool> predicate) => symbol.GetAttributes().Any(data => predicate(data.AttributeClass));
    internal static bool IsAsyncExtensionAttribute(INamedTypeSymbol? attribute) => attribute is { Name: "AsyncExtensionAttribute", ContainingAssembly.Name: "Ametrin.Optional" };
}
